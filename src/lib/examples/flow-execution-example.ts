import { flowExecutor } from '../services/FlowExecutor';
import type { FlowData } from '../types/automation';




const simpleFlow: FlowData = {
	id: 'simple-flow',
	name: 'Simple LLM to JIRA',
	nodes: [
		{
			id: 'llm-1',
			type: 'action',
			nodeType: 'action',
			category: 'llm',
			data: {
				label: 'Generate Story',
				config: {
					prompt: 'Create a user story for: E-commerce checkout',
					model: 'gpt-4'
				}
			},
			position: { x: 100, y: 100 }
		},
		{
			id: 'jira-1',
			type: 'action',
			nodeType: 'action',
			category: 'jira-create-story',
			data: {
				label: 'Create JIRA Story',
				config: {
					project: 'ECOM',
					summary: '{{llm.response}}',
					description: 'Generated by AI'
				}
			},
			position: { x: 400, y: 100 }
		}
	],
	edges: [
		{
			id: 'llm-to-jira',
			source: 'llm-1',
			target: 'jira-1',
			type: 'default'
		}
	]
};


const complexFlow: FlowData = {
	id: 'complex-flow',
	name: 'Complex Multi-Branch Flow',
	nodes: [
		{
			id: 'trigger-1',
			type: 'trigger',
			nodeType: 'trigger',
			category: 'webhook',
			data: { label: 'Webhook Trigger' },
			position: { x: 50, y: 100 }
		},
		{
			id: 'llm-1',
			type: 'action',
			nodeType: 'action',
			category: 'llm',
			data: {
				label: 'Analyze Request',
				config: {
					prompt: 'Analyze this request: {{input}}',
					model: 'gpt-4'
				}
			},
			position: { x: 200, y: 100 }
		},
		{
			id: 'jira-story',
			type: 'action',
			nodeType: 'action',
			category: 'jira-create-story',
			data: {
				label: 'Create Story',
				config: {
					summary: '{{llm.response}}',
					project: 'PROJ'
				}
			},
			position: { x: 400, y: 50 }
		},
		{
			id: 'jira-comment',
			type: 'action',
			nodeType: 'action',
			category: 'jira-add-comment',
			data: {
				label: 'Add Comment',
				config: {
					comment: 'AI Analysis: {{llm.response}}',
					storyId: '{{jira-story.storyId}}'
				}
			},
			position: { x: 600, y: 100 }
		},
		{
			id: 'notification',
			type: 'action',
			nodeType: 'action',
			category: 'slack-message',
			data: {
				label: 'Send Notification',
				config: {
					message: 'Story created: {{jira-story.storyId}}'
				}
			},
			position: { x: 400, y: 150 }
		}
	],
	edges: [
		{ id: 'trigger-to-llm', source: 'trigger-1', target: 'llm-1' },
		{ id: 'llm-to-story', source: 'llm-1', target: 'jira-story' },
		{ id: 'llm-to-notification', source: 'llm-1', target: 'notification' },
		{ id: 'story-to-comment', source: 'jira-story', target: 'jira-comment' }
	]
};



export async function demonstrateFlowExecution() {
	console.log('üöÄ Flow Execution Demo');
	

	console.log('\nüìù Executing Simple Flow:');
	const result1 = await flowExecutor.executeFlow(simpleFlow);
	console.log('‚úÖ Execution Result:', {
		success: result1.success,
		duration: `${result1.totalDuration}ms`,
		order: result1.executionOrder
	});
	

	console.log('\nüîÄ Executing Complex Flow (Parallel):');
	const result2 = await flowExecutor.executeFlowParallel(complexFlow);
	console.log('‚úÖ Execution Result:', {
		success: result2.success,
		duration: `${result2.totalDuration}ms`,
		order: result2.executionOrder
	});
	

	console.log('\nüéØ Parallel Execution Groups:');
	const groups = flowExecutor.getParallelExecutionGroups(complexFlow.nodes, complexFlow.edges);
	groups.forEach((group, index) => {
		console.log(`Group ${index + 1}:`, group);
	});
}

/**
 * Error Handling: Circular Dependencies
 */
const circularFlow: FlowData = {
	id: 'circular-flow',
	name: 'Flow with Circular Dependency (Will Fail)',
	nodes: [
		{
			id: 'node-a',
			type: 'action',
			nodeType: 'action',
			category: 'llm',
			data: { label: 'Node A' },
			position: { x: 100, y: 100 }
		},
		{
			id: 'node-b',
			type: 'action',
			nodeType: 'action',
			category: 'jira-create-story',
			data: { label: 'Node B' },
			position: { x: 200, y: 100 }
		}
	],
	edges: [
		{ id: 'a-to-b', source: 'node-a', target: 'node-b' },
		{ id: 'b-to-a', source: 'node-b', target: 'node-a' }
	]
};

export async function demonstrateErrorHandling() {
	console.log('\n‚ùå Testing Circular Dependency Detection:');
	
	try {
		await flowExecutor.executeFlow(circularFlow);
	} catch (error) {
		console.log('‚úÖ Correctly caught error:', error instanceof Error ? error.message : String(error));
	}
}

/**
 * Benefits of Topological Sort Approach:
 * 
 * 1. ‚úÖ Guarantees correct execution order
 * 2. ‚úÖ Prevents infinite loops (detects cycles)
 * 3. ‚úÖ Enables parallel execution of independent nodes
 * 4. ‚úÖ Handles complex dependencies automatically
 * 5. ‚úÖ Scales to large workflows
 * 6. ‚úÖ Industry-standard approach (used by Airflow, Jenkins, etc.)
 */ 